<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE topic PUBLIC "-//OASIS//DTD DITA Topic//EN" "topic.dtd">
<topic id="configure_tls">
  <title>HPE Helion <tm tmtype="reg">OpenStack</tm> 2.0: Configuring TLS for Public Endpoints</title>
  <body>

    <section id="intro">
      
      <p outputclass="aTest">The Transport Layer Security (TLS) protocol, successor to SSL, provides the mechanisms to
        ensure authentication, non-repudiation, confidentiality, and integrity of user
        communications to the HPE Helion OpenStack services from public endpoints.</p>
      <p>OpenStack endpoints are HTTP (REST) services providing APIs to other OpenStack services on the
        management network. All traffic to OpenStack services coming in on the public endpoints are
        secured using TLS connections.</p>
      <p>All of the HPE Helion OpenStack 2.0 example cloud models ship with TLS enabled on the public
        API. Note that because TLS is enabled by default, a test certificate is bundled with the
        release. Having this default cert allows you to bring up a cloud without having to worry
        about certificates. It will not match your IP address, but you can ignore the warnings.
        Later, when you require a trusted certificate, you can add your own certificate and
        redeploy.</p> 
      <!--<p>
        <note type="warning">Here we are configuring and installing a test certificate. It is
          recommended that you create and sign certifcates properly for a production environment.
          TLS certificates used in production must adhere to the current Baseline Requirements.
          Furthermore, due to a known limitation in the Python codebase, you must ensure additional
          standards are met, all of which are outlined at the end of this document in <xref
            href="#topic_yym_nps_4t/rfcs" format="dita">Critical Standards for Certificates in
            Production Environments</xref>.</note>
      </p>-->
    </section>
    <section> When logging into the lifecycle manager to run the configuration processor and the
      requisite playbooks, you must decide if you want to configure the external VIP with an FQDN or
      just leave it as an IP address. This can't be changed after deployment. Therefore, you will
      have to make one of the following changes:<ul id="ul_sdj_qfq_rt">
        <li>Comment out the "external-name:" line in
          /home/stack/helion/my_cloud/definition/data/network_groups.yml (so that IP addresses are
          used) </li>
        <li>Assign a name to "external-name:" line in
          /home/stack/helion/my_cloud/definition/data/network_groups.yml (so that an FQDN is
          used)</li>
      </ul>
    </section>

    <section>
      <title>Creating a self-signed certificate</title>
      If you want to install a
      self-signed certificate that meets the needs of  HPE Helion OpenStack and HPE Helion Development
      Platform, follow these steps to create the cert, and then install it by following the
      installation steps.<ol id="ol_wmt_wsp_tt">
        <li>Create a Certificate Signing Request (CSR) with a defined subject:
          <codeblock>openssl req -nodes -days 365 -newkey rsa:2048 -keyout my-public-cert.key -out my-public-cert.csr -text \
        -subj '/C=US/O=Helion Test Certificate/CN=your.domain.com/emailAddress=test@ficticious.org/'</codeblock>
        </li>
        <li>Create a file containing v3 extensions Ensure that the DNS entry matches any CN entry
          above and provide your IP
          <codeblock>cat > v3_ext.cnf &lt;&lt; *EOF*
[ v3_req ]
subjectAltName=DNS:your.domain.com,DNS:10.0.0.1, IP:10.0.0.1
*EOF*</codeblock>
        </li>
        <li>Self-sign your certificate
          <codeblock>openssl x509 -extfile v3_ext.cnf -extensions v3_req -in my-public-cert.csr -signkey my-public-cert.key -req -text -out my-public-cert.crt</codeblock>
          Note that the domain name in the certificate signing request in step 1 and the DNS entry
          in step 2 must match, although the domain do not have to exist. <p>In step 2 you need the
            same IP address listed for both the DNS and the IP entries. The IP address is what is
            used by HPE Helion Development Platform and the DNS is used by HPE Helion OpenStack. Note
            that is you examine the output certificate, the issuer will match the subject because
            the cert is self-signed. The requirement for the DNS entry stems from a low-level Python
            bug.</p>
        </li>
      </ol>
      <!--Follow these steps to
      create a certificate for non-production environments. <ol>
        <li> Make sure you have OpenSSL installed.
          <codeblock>openssl req -x509 -nodes -days 365 -newkey rsa:2048 -keyout my-public-cert.key -out my-public-cert.crt</codeblock>
          You must provide details when prompted. Make sure you provide your FQDN or IP address of
          the VIP when prompted for Common Name. </li>
        <li>Append the certificate to the key for haproxy-required format.
          <codeblock>cat my-public-cert.key my-public-cert.crt > my-public-cert</codeblock></li>
            
      </ol> You can now use my-public-cert as your certificate. -->
      <p><b>Installing the Certificate</b></p> Follow the steps below to install the certificate in
      the cloud.</section>
    <section><b>If you are using a FQDN:</b>
      <ol id="ol_ngj_qfq_rt">
        <li> Create or obtain a certificate to match the domain name you are going to use. </li>
        <li> Copy the certificate (containing both public and private keys) to
            <b>helion/my_cloud/config/tls/certs/ </b></li>
        <li id="private1">Replace the contents of
            <b>~/scratch/ansible/next/hos/ansible/roles/tls-trust/files/frontend_cacert.pem</b> with
          the new CA certificate chain file (if applicable)</li>
        <li>Edit <b>network_groups.yml </b>(as part of the general set of edits they have to make to
          the example) to set the values for "external-name" and "cert-file" </li>
        <li>Commit your changes to git:
          <codeblock>cd ~/helion/hos/ansible
git add -A
git commit -m "My config or other commit message"</codeblock></li>
        <li>Run the config
          processor:<codeblock>cd ~/helion/hos/ansible
ansible-playbook -i hosts/localhost config-processor-run.yml</codeblock></li>
        <li>Now, in order for the certificate to be enabled, you must take one of the following
          actions. Run: <ul>
            <li>A site deploy play</li>
            <li>An upgrade play</li>
            <li>or redeploy FND_CLU like so:
              <codeblock>ansible-playbook -i hosts/verb_hosts FND-CLU-deploy.yml</codeblock>
            </li>
          </ul>
        </li>
        <li>Continue with the deployment as usual.</li>
      </ol>
      <b>If you are using IP addresses for external ULRs: </b><ol id="ol_y3j_qfq_rt">
        <li>Edit <b>network_groups.yml</b> to comment out the "external-name" line </li>
        <li>Commit your changes to git and run the configuration processor as in steps 4 and 5
          above</li>
        <li>Note the IP address used for the public URLs (from
          <b>my_cloud/info/address_info.ym</b>l) </li>
        <li>Create or obtain a certificate tied to this address </li>
        <li>Copy the certificate (containing both public and private keys) to
            <b>helion/my_cloud/config/tls/certs/ </b></li>
        <li id="private2">Replace the contents of<b>
            ~/scratch/ansible/next/hos/ansible/roles/tls-trust/files/frontend_cacert.pem</b> with
          the new CA certificate chain file (if applicable) </li>
        <li>Edit <b>network_groups.yml </b>to set the value for the name of the "cert-file"</li>
        <li>Again, commit your changes to git and run the configuration processor as in steps 4 and
          5 above</li>
        <li>Continue with the deployment as usual</li>
      </ol> Note that the certificate that is installed by default, "my-public-cert", is linked to
      the name "myhelion.test". It is possible to deploy the system without generating or
      configuring a new certificate and come back and change it later, but access to the public URLS
      will have to use the "--insecure" flag to avoid "certificate mismatch" errors.</section>
    <section> Here is the relevant section of
      <b>network_groups.yml</b>.<codeblock> load-balancers: 
   - provider: ip-cluster
     name: extlb   # This is the external load balancer.
         # If external-name is set then public urls in keystone
         # will use this name instead of the IP address.
         # You must either set this to a name that can be resolved in your network
         # or comment out this line to use IP addresses

         external-name:

     tls-components:
        - default
     roles:
        - public
          cert-file: my-public-cert   # this cert should match the FQDN for authenticated TLS to work. 
                                      # The bundled test certificate is for myhelion.test</codeblock></section>
    <section id="TLS_termination">
      <title>Definitions</title>
      <dl>
        <dlentry>
          <dt>name: extlb</dt>
          <dd>The external load balancer</dd>
        </dlentry>
        <dlentry>
          <dt>external-name:</dt>
          <dd>This name will be used in place of the external VIP address. This name can be an FQDN.
            This will be registered in the public endpoints of the services. As noted above,
            myhelion.test should be changed to your FQDN.</dd>
        </dlentry>
        <dlentry>
          <dt>tls-components:</dt>
          <dd>This list of services will be put behind TLS. Note this is only being done for the
            load balancer in question, which is the external load balancer. The components in
            'default' are those services defined under service-components in data/control_plane.yml.
            If you want to have a finer granularity, you can replace default with a list of
            individual components, such as: <codeblock>tls-components: - 'horizon' </codeblock></dd>
        </dlentry>
        <dlentry>
          <dt>cert-file:</dt>
          <dd> the default my-public-cert is already part of the playbook but you can specify your
            own name. When you specify your own you also need to have the certificate copied in
              <b>~/helion/my_cloud/config/tls/certs</b> on the lifecycle manager, as noted above. </dd>
        </dlentry>
      </dl>
      <note>Do not enable TLS to the internal load balancer. </note>
    </section>
    
    

    <section><title>Disabling TLS</title>If you don't want to use TLS, then you should change "tls-components" to "components"
      in <b>network_groups.yml</b>. Additionally, if you have a <b>network_groups.yml</b> file from
      a previous installation, you won't have TLS enabled unless you change "components" to
      "tls-components" in that file. </section>
    <section id="configure_cipher">
      <title>Configuring the cipher suite for public endpoints</title> We have set the default
      cipher suite to be: <codeph>HIGH:!aNULL:!eNULL:!DES:!3DES</codeph>. This is a recommended
      setting from the <xref
        href="http://docs.openstack.org/security-guide/secure-communication/introduction-to-ssl-and-tls.html"
        format="html" scope="external">OpenStack documentation site</xref>. You may override this.
      To do so, open <b>config/haproxy/defaults.yml</b> and edit it. The parameters can be found
      under haproxy_globals list.
      <codeblock>- "ssl-default-bind-ciphers HIGH:!aNULL:!eNULL:!DES:!3DES"
- "ssl-default-server-ciphers HIGH:!aNULL:!eNULL:!DES:!3DES"</codeblock>
      Make the changes as needed. It's best to keep the two options identical. </section>
    <!--
    <section id="rfcs"><title>Critical Standards for Certificates in Production Environments</title>
      
      <note type="warning">TLS certificates must adhere to the current <xref
        href="https://cabforum.org/wp-content/uploads/Baseline_Requirements_V1_3_1.pdf"
        format="pdf" scope="external">Baseline Requirements</xref>. Furthermore, due to a known
        limitation in the Python codebase, you must ensure the following standards are met:<dl>
          <dlentry>
            <dt>If Using IP Addresses</dt>
            <dd>The Common Name attribute (<codeph>commonName</codeph>) <xref
              href="https://cabforum.org/wp-content/uploads/Baseline_Requirements_V1_3_1.pdf"
              format="pdf" scope="external">has been deprecated</xref> and it is recommended that
              you do not use it.</dd>
            <dd>The Common Name attribute must not contain an IP address per <xref
              href="https://tools.ietf.org/html/rfc2818" format="html" scope="external">RFC
              2818</xref>.</dd>
            <dd>Create an <codeph>IP Address</codeph> alternative name entry
              (<codeph>SubjectAltName</codeph>) attribute that contains the IP address.</dd>
            <dd>Create an additional <codeph>DNS</codeph> alternative name entry attribute that
              contains the same IP address. </dd>
            <dd>Example:
              <codeblock>X509v3 Subject Alternative Name:
DNS:servername-api.ftc.hp.com, DNS:10.241.20.5, IP Address:10.241.20.5</codeblock></dd>
          </dlentry>
          <dlentry>
            <dt>If Using DNS/FQDN</dt>
            <dd>The Common Name attribute (<codeph>commonName</codeph>) has been deprecated and it
              is recommended that you do not use it. The Common Name attribute must not contain an
              IP address per <xref href="https://tools.ietf.org/html/rfc2818" format="html"
                scope="external">RFC 2818</xref>.</dd>
            <dd>If the Common Name attribute is specified, there must also be an alternative name
              entry specified which contains the DNS information. (At least one Subject Alternative
              Name (<codeph>subjectAltName</codeph>) extension attributes must be specified, or some
              services will fail to install or to function.)</dd>
            <dd>
              <codeblock>CN=servername-api.ftc.hp.com/emailAddress=email-address@hp.com
X509v3 Subject Alternative Name:
DNS:servername-api.ftc.hp.com</codeblock>
            </dd>
          </dlentry>
        </dl></note><p>You must also supply the name of a certificate file that matches your choice
          above. If you are using IP addresses, you won't know the IP address until after the config
          processor has run, but you can obtain it after running the config processor and before
          deployment. </p>
      
      
    </section>-->
    <!--
    <section><title>Creating a test certificate for an IP address or FQDN</title> If you want to
      create a test certificate, follow tese steps: <ol>
        <li>First get the IP address or FQDN your public endpoint is bound to. </li>
        <li>you need to get the following files and run a script. <ul>
            <li>cacert.pem </li>
            <li>cakey.pem </li>
            <li>openssl.cnf </li>
            <li>hlm_cert_generate.sh</li>
          </ul>
        </li>
        <li> Then run <codeblock>bash hlm_cert_generate.sh &lt;public VIP address></codeblock> or
          <codeblock>bash hlm_cert_generate.sh &lt;public FQDN></codeblock>
        </li>
      </ol>
      <b>Installing the new certificate into a running cloud</b>
      <ol>
        <li>Copy the generated my-public-cert to <b>~/helion/my_cloud/config/tls/certs/</b>
        </li>
        <li>Commit the changes, run the config processor and deploy cluster playbook.
          <codeblock>cd ~/helion/hos/ansible
ansible-playbook -i hosts/localhost config-processor-clean.yml</codeblock>
        </li>
        <li>Commit your changes to git.
          <codeblock>cd ~/helion/hos/ansible
git add -A
git commit -m "My config or other commit message"</codeblock>
        </li>
        <li>Rerun the config processor
          <codeblock>ansible-playbook -i hosts/localhost config-processor-run.yml</codeblock>
        </li>
        <li>Deploy the cluster to refresh the certificate
          <codeblock>cd ~/scratch/ansible/next/hos/ansible
ansible-playbook -i hosts/verb_hosts FND-CLU-deploy.yml</codeblock>
        </li>
      </ol>  
    </section>-->
    
    
  
    
    
    
    <!--<section><title>Accessing public endpoints from an external machine</title>
      <ol id="ol_q1b_djg_rt">
        <li>Have a name resolver for myhelion.test - It could /etc/hosts or dnsmasq reading from a
          hosts file </li>
        <li>Install the CA certificate that signed the test server certificate. This file can be
          found in the lifecycle manager under <b>roles/tls-trust/files/frontend_cacert.pem</b>. </li>
        <li>Make an entry for the VIP inside the /etc/hosts file pointing to myhelion.test </li>
        <li>Run the playbook below to install the certificate.
          <codeblock>ansible-playbook -i hosts/verb_hosts tls-trust-deploy.yml</codeblock></li>
      </ol></section>--> 
 <!--
    <section><title>Testing public endpoints using the test certificate with a virtual cloud</title>
      The following write up is for people trying to test the public endpoints using the bundled
      test certificate with a virtual cloud. There are three use cases here. <ul id="ul_z51_djg_rt">
        <li>Access public endpoints from the lifecycle manager </li>
        <li>Access public endpoints from the machine hosting the virtual cloud </li>
        <li>Access public endpoints from a machine other than the machine hosting the virtual cloud
        </li>
      </ul>All these cases reduce to the following steps <ol id="ol_ay1_djg_rt">
        <li>Have a name resolver for myhelion.test - It could /etc/hosts or dnsmasq reading from a
          hosts file </li>
        <li>Install the CA certificate that signed the test server certificate. This file can be
          found in the lifecycle manager under <b>roles/tls-trust/files/frontend_cacert.pem</b>. This file is
          not symlinked via the config directory to customers because we generally don't need the CA
          certificate signing the external certificate inside the cloud. </li>
      </ol>
   
      <b>Accessing public endpoints from the machine hosting the virtual cloud</b>
      <ol id="ol_ddb_djg_rt">
        <li>Make an entry for the VIP inside the /etc/hosts file pointing to myhelion.test </li>
        <li>Copy the CA certificate from the
          lifecycle manager:/home/stack/scratch/ansible/next/hos/ansible/roles/tls-trust/files/frontend_cacert.pem
          to /usr/local/share/ca-certificates/helion-ca.crt </li>
        <li>Run <codeblock>sudo update-ca-certificates - -fresh</codeblock></li>
      </ol>
      
    </section>
    <section><title><b>Accessing public endpoints from a machine other than the machine hosting the virtual
      cloud</b></title>Start by repeating what was done for the machine hosting the virtual cloud. But this
      time your /etc/hosts entry for myhelion.test should point to the IP address of the host
      running the virtual cloud. After this you need to have something tunnelling the packets to the
      VIP. This is easily accomplished with haproxy in tunnel mode. (mode tcp). But you need to have
      a stanza for every open port. But the stanzas are quite generic and can be scripted. For
      example if I want to do 'nova list' I may need port 5000 (keystone) and port 8774 (nova-api),
        <ol id="ol_ofb_djg_rt">
        <li>Install haproxy with apt-get </li>
        <li>Open<b> /etc/haproxy/haproxy.cfg</b> and append the following sections to the existing
          content:
          <codeblock>listen keystone-5000
      option ssl-hello-chk
      mode tcp
      bind 16.25.10.10:5000
      server keystone-5000 192.168.245.10:5000 check inter 2000 rise 2 fall 5
      listen nova-8774
      option ssl-hello-chk
      mode tcp
      bind 16.25.10.10:8774
      server nova-8774 192.168.245.10:8774 check inter 2000 rise 2 fall 5
      
      16.25.10.10 is the host running the virtual cloud
      192.168.254.10 is the VIP</codeblock></li>
      </ol> One way to generate the list of all public ports behind TLS is to run 'grep "ssl crt"
      /etc/haproxy/haproxy.cfg' from a controller. </section>-->
  </body>
</topic>
